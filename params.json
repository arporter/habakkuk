{
  "name": "Habakkuk",
  "tagline": "Fortran code analysis for performance prediction",
  "body": "# habbakuk #\r\nFortran code analysis for performance prediction\r\n\r\n## Getting started ##\r\n\r\nYou will need the 'git' revision control system installed. You\r\ncan then clone the repository to your local machine:\r\n\r\n    git clone https://github.com/arporter/habbakuk.git\r\n\r\nYou will then need to set your python path like so:\r\n\r\n    cd habbakuk\r\n    export PYTHONPATH=${PWD}/f2py_93:${PWD}/src\r\n\r\nHaving done this you should be all set to try the tool on\r\nsome Fortran code. There are various examples in src/tests/test_files.\r\nThe tool may be run like so:\r\n\r\n    cd habbakuk/src\r\n    python ./make_dag.py tests/test_files/triple_product.f90\r\n\r\nYou should then see output similar to the following:\r\n\r\n    Wrote DAG to test_triple_product.gv\r\n    Stats for DAG test_triple_product:\r\n      0 addition operators.\r\n      0 subtraction operators.\r\n      2 multiplication operators.\r\n      0 division operators.\r\n      0 fused multiply-adds.\r\n      2 FLOPs in total.\r\n      0 array references.\r\n      0 distinct cache-line references.\r\n      Did not find any array/memory references\r\n      Whole DAG in serial:\r\n        Sum of cost of all nodes = 2 (cycles)\r\n        2 FLOPs in 2 cycles => 1.0000*CLOCK_SPEED FLOPS\r\n      Everything in parallel to Critical path:\r\n        Critical path contains 4 nodes, 2 FLOPs and is 2 cycles long\r\n        FLOPS (ignoring memory accesses) = 1.0000*CLOCK_SPEED\r\n    Wrote DAG to test_triple_product_step0.gv\r\n    Wrote DAG to test_triple_product_step1.gv\r\n    Wrote DAG to test_triple_product_step2.gv\r\n    Schedule contains 2 steps:\r\n    0 * None (cost = 1)\r\n    1 * None (cost = 1)\r\n      Estimate using computed schedule:\r\n        Cost of schedule as a whole = 2 cycles\r\n        FLOPS from schedule (ignoring memory accesses) = 1.0000*CLOCK_SPEED\r\n      Estimate using perfect schedule:\r\n        Cost if all ops on different execution ports are perfectly overlapped = 2 cycles\r\n      e.g. at 3.85 GHz, these different estimates give (GFLOPS): \r\n      No ILP  |  Computed Schedule  |  Perfect Schedule | Critical path\r\n       3.85   |          3.85       |        3.85       |    3.85\r\n    No opportunities to fuse multiply-adds\r\n\r\nThe tool produces a Directed Acyclic Graph (DAG) for the body of the\r\ninner-most loop of every loop-nest it encounters. If a routine (or main\r\nprogram unit) contains no loops then a DAG is generated for the executable\r\npart of that routine. Each DAG is written to file in the dot language (e.g.\r\ntest_triple_product.gv in the above example). If you have dot installed\r\n(part of the graphviz package) then you can process these files to produce\r\nan image of the DAG, e.g.:\r\n\r\n    cat triple_product_test.gv | dot -Tpng > triple.png\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}